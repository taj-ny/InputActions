/*
    Input Actions - Input handler that executes user-defined actions
    Copyright (C) 2024-2026 Marcin Wo≈∫niak

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#pragma once

#include "InputDeviceProperties.h"
#include "InputDeviceState.h"
#include <QPointF>
#include <QRegularExpression>
#include <QSizeF>
#include <QTimer>
#include <libinputactions/globals.h>
#include <libinputactions/input/InputEventHandler.h>
#include <linux/input-event-codes.h>

namespace InputActions
{

class TouchpadTriggerHandler;
class TouchscreenTriggerHandler;

static const std::map<uint32_t, Qt::KeyboardModifier> KEYBOARD_MODIFIERS{
    {KEY_LEFTALT, Qt::KeyboardModifier::AltModifier},
    {KEY_LEFTCTRL, Qt::KeyboardModifier::ControlModifier},
    {KEY_LEFTMETA, Qt::KeyboardModifier::MetaModifier},
    {KEY_LEFTSHIFT, Qt::KeyboardModifier::ShiftModifier},
    {KEY_RIGHTALT, Qt::KeyboardModifier::AltModifier},
    {KEY_RIGHTCTRL, Qt::KeyboardModifier::ControlModifier},
    {KEY_RIGHTMETA, Qt::KeyboardModifier::MetaModifier},
    {KEY_RIGHTSHIFT, Qt::KeyboardModifier::ShiftModifier},
};

/**
 * Events generated by the device must be processed in the following order:
 *  - InputDevice::handleEvent - Updates physical state, never blocks the event
 *  - All input event handlers
 *  - InputDevice::handleNotBlockedEvent - Updates virtual state, never blocks the event, call only if the event was not blocked before
 */
class InputDevice
    : public QObject
    , public InputEventHandler
{
    Q_OBJECT

public:
    /**
     * @param name Full name of the device.
     * @param sysName Name of the device in /dev/input (e.g. event6).
     */
    InputDevice(InputDeviceType type, QString name = {}, QString sysName = {});
    ~InputDevice() override;

    const InputDeviceType &type() const { return m_type; }
    const QString &name() const { return m_name; }
    const QString &sysName() const { return m_sysName; }
    InputDeviceProperties &properties() { return m_properties; }
    const InputDeviceProperties &properties() const { return m_properties; }

    TouchpadTriggerHandler *touchpadTriggerHandler() const { return m_touchpadTriggerHandler.get(); }
    void setTouchpadTriggerHandler(std::unique_ptr<TouchpadTriggerHandler> value);

    TouchscreenTriggerHandler *touchscreenTriggerHandler() const { return m_touchscreenTriggerHandler.get(); }
    void setTouchscreenTriggerHandler(std::unique_ptr<TouchscreenTriggerHandler> value);

    /**
     * The device's true state.
     */
    InputDeviceState &physicalState() { return m_physicalState; }
    const InputDeviceState &physicalState() const { return m_physicalState; }
    /**
     * The device's state as seen by another entity that is handling it - the compositor and its libinput instance, an external libinput instance, evtest,
     * etc. InputActions manipulates this state in various ways for the purposes of event filtering.
     *
     * Only keyboard keys and modifiers are available to query in this state.
     */
    const InputDeviceState &virtualState() const { return m_virtualState; }

    /**
     * Simulates a keyboard key press event and modifiers the virtual state. Must be called by the overriding method.
     */
    virtual void keyboardKey(uint32_t key, bool state);
    /**
     * Simulates a mouse button press event.
     */
    virtual void mouseButton(uint32_t button, bool state) {}

    /**
     * @param points Raw positions.
     * @see TouchPoint::rawPosition
     */
    void touchscreenTap(const std::vector<QPointF> &points);

    /**
     * Sets the device's virtual state into a neutral one. In the standalone implementation, the device must be grabbed, otherwise the call will be ignored.
     *
     * This operation is currently only used for touchscreens and touchpads (standalone only).
     */
    virtual void resetVirtualDeviceState() {}
    /**
     * Restores the device's virtual state to the physical one. In the standalone implementation, the device must be grabbed, otherwise the call will be
     * ignored.
     *
     * This operation is currently only used for touchscreens and touchpads (standalone only).
     *
     * The touchscreen restore sequence must include the following elements:
     *   - Touch down - at initial raw positions
     *   - Touch frame
     *   - Touch motion - from initial raw positions to current raw positions (accounts for InputActions' motion threshold)
     *   - Touch frame
     * More elements may be added by the implementation if necessary.
     */
    virtual void restoreVirtualDeviceState() {}

    void handleNotBlockedEvent(const InputEvent &event);

protected:
    /**
     * Must generate touch down events and a touch frame event for the specified points.
     * @param points Raw positions.
     * @see TouchPoint::rawPosition
     */
    virtual void touchscreenTapDown(const std::vector<QPointF> &points) {}
    /**
     * Must generate touch up events and a touch frame event for the specified points.
     * @param points Raw positions.
     * @see TouchPoint::rawPosition
     */
    virtual void touchscreenTapUp(const std::vector<QPointF> &points) {}

    bool keyboardKey(const KeyboardKeyEvent &event) override;

    bool touchCancel(const TouchCancelEvent &event) override;
    bool touchDown(const TouchDownEvent &event) override;
    bool touchMotion(const TouchMotionEvent &event) override;
    bool touchPressureChange(const TouchPressureChangeEvent &event) override;
    bool touchUp(const TouchUpEvent &event) override;

private slots:
    void onTouchscreenTapTimerTimeout();

private:
    void updatePointState(int32_t id, uint32_t pressure);

    InputDeviceType m_type;
    QString m_name;
    QString m_sysName;
    InputDeviceProperties m_properties;

    std::unique_ptr<TouchpadTriggerHandler> m_touchpadTriggerHandler;

    QTimer m_touchscreenTapTimer;
    std::vector<QPointF> m_touchscreenTapPoints;
    std::unique_ptr<TouchscreenTriggerHandler> m_touchscreenTriggerHandler;

    InputDeviceState m_physicalState;
    InputDeviceState m_virtualState;
};

}